<?php
/**
 * ModelApi
 * PHP version 7.4
 *
 * @category Class
 * @package  ShapeDiver\GeometryApiV2\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Geometry Backend API v2
 *
 * The ShapeDiver Geometry Backend system is used to: * host Grasshopper models in a secure, reliable, scalable, and performant way, * run computations of Grasshopper models, * and cache and output the results of computations and exports.
 *
 * The version of the OpenAPI document: 1.12.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ShapeDiver\GeometryApiV2\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ShapeDiver\GeometryApiV2\Client\ApiException;
use ShapeDiver\GeometryApiV2\Client\Configuration;
use ShapeDiver\GeometryApiV2\Client\HeaderSelector;
use ShapeDiver\GeometryApiV2\Client\ObjectSerializer;

/**
 * ModelApi Class Doc Comment
 *
 * @category Class
 * @package  ShapeDiver\GeometryApiV2\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ModelApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'cleanupExports' => [
            'application/json',
        ],
        'cleanupOutputs' => [
            'application/json',
        ],
        'cleanupTextures' => [
            'application/json',
        ],
        'createModel' => [
            'application/json',
        ],
        'createModelConfig' => [
            'application/json',
        ],
        'deleteModel' => [
            'application/json',
        ],
        'downloadModelFile' => [
            'application/json',
        ],
        'getCleanupStatus' => [
            'application/json',
        ],
        'getModel' => [
            'application/json',
        ],
        'getModelComputations' => [
            'application/json',
        ],
        'getModelConfig' => [
            'application/json',
        ],
        'listModels' => [
            'application/json',
        ],
        'restoreModel' => [
            'application/json',
        ],
        'updateModel' => [
            'application/json',
        ],
        'updateModelConfig' => [
            'application/json',
        ],
        'updateParameterDefaultValues' => [
            'application/json',
        ],
        'updateParameterDefinitions' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation cleanupExports
     *
     * Delete old export components.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupExports'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports|\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function cleanupExports($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupExports'][0])
    {
        list($response) = $this->cleanupExportsWithHttpInfo($modelId, $untilLastSeen, $contentType);
        return $response;
    }

    /**
     * Operation cleanupExportsWithHttpInfo
     *
     * Delete old export components.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupExports'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports|\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function cleanupExportsWithHttpInfo($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupExports'][0])
    {
        $request = $this->cleanupExportsRequest($modelId, $untilLastSeen, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 202:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cleanupExportsAsync
     *
     * Delete old export components.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupExports'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cleanupExportsAsync($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupExports'][0])
    {
        return $this->cleanupExportsAsyncWithHttpInfo($modelId, $untilLastSeen, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cleanupExportsAsyncWithHttpInfo
     *
     * Delete old export components.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupExports'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cleanupExportsAsyncWithHttpInfo($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupExports'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupExports';
        $request = $this->cleanupExportsRequest($modelId, $untilLastSeen, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cleanupExports'
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupExports'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cleanupExportsRequest($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupExports'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling cleanupExports'
            );
        }

        // verify the required parameter 'untilLastSeen' is set
        if ($untilLastSeen === null || (is_array($untilLastSeen) && count($untilLastSeen) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $untilLastSeen when calling cleanupExports'
            );
        }
        if (!preg_match("/^(\\d{4}|\\d{6}|\\d{8}|\\d{10}|\\d{12}|\\d{14}|\\d{17})$/", $untilLastSeen)) {
            throw new \InvalidArgumentException("invalid value for \"untilLastSeen\" when calling ModelApi.cleanupExports, must conform to the pattern /^(\\d{4}|\\d{6}|\\d{8}|\\d{10}|\\d{12}|\\d{14}|\\d{17})$/.");
        }
        

        $resourcePath = '/api/v2/model/{modelId}/cleanup/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $untilLastSeen,
            'untilLastSeen', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cleanupOutputs
     *
     * Delete old output components.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupOutputs'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs|\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function cleanupOutputs($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupOutputs'][0])
    {
        list($response) = $this->cleanupOutputsWithHttpInfo($modelId, $untilLastSeen, $contentType);
        return $response;
    }

    /**
     * Operation cleanupOutputsWithHttpInfo
     *
     * Delete old output components.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupOutputs'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs|\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function cleanupOutputsWithHttpInfo($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupOutputs'][0])
    {
        $request = $this->cleanupOutputsRequest($modelId, $untilLastSeen, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 202:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cleanupOutputsAsync
     *
     * Delete old output components.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupOutputs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cleanupOutputsAsync($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupOutputs'][0])
    {
        return $this->cleanupOutputsAsyncWithHttpInfo($modelId, $untilLastSeen, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cleanupOutputsAsyncWithHttpInfo
     *
     * Delete old output components.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupOutputs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cleanupOutputsAsyncWithHttpInfo($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupOutputs'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupOutputs';
        $request = $this->cleanupOutputsRequest($modelId, $untilLastSeen, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cleanupOutputs'
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupOutputs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cleanupOutputsRequest($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupOutputs'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling cleanupOutputs'
            );
        }

        // verify the required parameter 'untilLastSeen' is set
        if ($untilLastSeen === null || (is_array($untilLastSeen) && count($untilLastSeen) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $untilLastSeen when calling cleanupOutputs'
            );
        }
        if (!preg_match("/^(\\d{4}|\\d{6}|\\d{8}|\\d{10}|\\d{12}|\\d{14}|\\d{17})$/", $untilLastSeen)) {
            throw new \InvalidArgumentException("invalid value for \"untilLastSeen\" when calling ModelApi.cleanupOutputs, must conform to the pattern /^(\\d{4}|\\d{6}|\\d{8}|\\d{10}|\\d{12}|\\d{14}|\\d{17})$/.");
        }
        

        $resourcePath = '/api/v2/model/{modelId}/cleanup/output';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $untilLastSeen,
            'untilLastSeen', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cleanupTextures
     *
     * Delete old texture components.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupTextures'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures|\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function cleanupTextures($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupTextures'][0])
    {
        list($response) = $this->cleanupTexturesWithHttpInfo($modelId, $untilLastSeen, $contentType);
        return $response;
    }

    /**
     * Operation cleanupTexturesWithHttpInfo
     *
     * Delete old texture components.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupTextures'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures|\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function cleanupTexturesWithHttpInfo($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupTextures'][0])
    {
        $request = $this->cleanupTexturesRequest($modelId, $untilLastSeen, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 202:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cleanupTexturesAsync
     *
     * Delete old texture components.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupTextures'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cleanupTexturesAsync($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupTextures'][0])
    {
        return $this->cleanupTexturesAsyncWithHttpInfo($modelId, $untilLastSeen, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cleanupTexturesAsyncWithHttpInfo
     *
     * Delete old texture components.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupTextures'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cleanupTexturesAsyncWithHttpInfo($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupTextures'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResCleanupTextures';
        $request = $this->cleanupTexturesRequest($modelId, $untilLastSeen, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cleanupTextures'
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $untilLastSeen Delete all components that have been used last at or before this timestamp. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cleanupTextures'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cleanupTexturesRequest($modelId, $untilLastSeen, string $contentType = self::contentTypes['cleanupTextures'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling cleanupTextures'
            );
        }

        // verify the required parameter 'untilLastSeen' is set
        if ($untilLastSeen === null || (is_array($untilLastSeen) && count($untilLastSeen) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $untilLastSeen when calling cleanupTextures'
            );
        }
        if (!preg_match("/^(\\d{4}|\\d{6}|\\d{8}|\\d{10}|\\d{12}|\\d{14}|\\d{17})$/", $untilLastSeen)) {
            throw new \InvalidArgumentException("invalid value for \"untilLastSeen\" when calling ModelApi.cleanupTextures, must conform to the pattern /^(\\d{4}|\\d{6}|\\d{8}|\\d{10}|\\d{12}|\\d{14}|\\d{17})$/.");
        }
        

        $resourcePath = '/api/v2/model/{modelId}/cleanup/texture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $untilLastSeen,
            'untilLastSeen', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createModel
     *
     * Create model.
     *
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\ReqModel $reqModel reqModel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModel'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResCreateModel|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function createModel($reqModel, string $contentType = self::contentTypes['createModel'][0])
    {
        list($response) = $this->createModelWithHttpInfo($reqModel, $contentType);
        return $response;
    }

    /**
     * Operation createModelWithHttpInfo
     *
     * Create model.
     *
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\ReqModel $reqModel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModel'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResCreateModel|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createModelWithHttpInfo($reqModel, string $contentType = self::contentTypes['createModel'][0])
    {
        $request = $this->createModelRequest($reqModel, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCreateModel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCreateModel' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResCreateModel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResCreateModel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResCreateModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createModelAsync
     *
     * Create model.
     *
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\ReqModel $reqModel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModelAsync($reqModel, string $contentType = self::contentTypes['createModel'][0])
    {
        return $this->createModelAsyncWithHttpInfo($reqModel, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createModelAsyncWithHttpInfo
     *
     * Create model.
     *
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\ReqModel $reqModel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModelAsyncWithHttpInfo($reqModel, string $contentType = self::contentTypes['createModel'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResCreateModel';
        $request = $this->createModelRequest($reqModel, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createModel'
     *
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\ReqModel $reqModel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createModelRequest($reqModel, string $contentType = self::contentTypes['createModel'][0])
    {

        // verify the required parameter 'reqModel' is set
        if ($reqModel === null || (is_array($reqModel) && count($reqModel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reqModel when calling createModel'
            );
        }


        $resourcePath = '/api/v2/model';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($reqModel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($reqModel));
            } else {
                $httpBody = $reqModel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createModelConfig
     *
     * Create model config.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,mixed> $requestBody requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModelConfig'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResCreateModelConfig|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function createModelConfig($modelId, $requestBody, string $contentType = self::contentTypes['createModelConfig'][0])
    {
        list($response) = $this->createModelConfigWithHttpInfo($modelId, $requestBody, $contentType);
        return $response;
    }

    /**
     * Operation createModelConfigWithHttpInfo
     *
     * Create model config.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,mixed> $requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModelConfig'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResCreateModelConfig|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createModelConfigWithHttpInfo($modelId, $requestBody, string $contentType = self::contentTypes['createModelConfig'][0])
    {
        $request = $this->createModelConfigRequest($modelId, $requestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCreateModelConfig' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResCreateModelConfig' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResCreateModelConfig', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResCreateModelConfig';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResCreateModelConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createModelConfigAsync
     *
     * Create model config.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,mixed> $requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModelConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModelConfigAsync($modelId, $requestBody, string $contentType = self::contentTypes['createModelConfig'][0])
    {
        return $this->createModelConfigAsyncWithHttpInfo($modelId, $requestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createModelConfigAsyncWithHttpInfo
     *
     * Create model config.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,mixed> $requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModelConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModelConfigAsyncWithHttpInfo($modelId, $requestBody, string $contentType = self::contentTypes['createModelConfig'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResCreateModelConfig';
        $request = $this->createModelConfigRequest($modelId, $requestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createModelConfig'
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,mixed> $requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModelConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createModelConfigRequest($modelId, $requestBody, string $contentType = self::contentTypes['createModelConfig'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling createModelConfig'
            );
        }

        // verify the required parameter 'requestBody' is set
        if ($requestBody === null || (is_array($requestBody) && count($requestBody) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $requestBody when calling createModelConfig'
            );
        }


        $resourcePath = '/api/v2/model/{modelId}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($requestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($requestBody));
            } else {
                $httpBody = $requestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteModel
     *
     * Delete model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModel'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function deleteModel($modelId, string $contentType = self::contentTypes['deleteModel'][0])
    {
        list($response) = $this->deleteModelWithHttpInfo($modelId, $contentType);
        return $response;
    }

    /**
     * Operation deleteModelWithHttpInfo
     *
     * Delete model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModel'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteModelWithHttpInfo($modelId, string $contentType = self::contentTypes['deleteModel'][0])
    {
        $request = $this->deleteModelRequest($modelId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteModelAsync
     *
     * Delete model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModelAsync($modelId, string $contentType = self::contentTypes['deleteModel'][0])
    {
        return $this->deleteModelAsyncWithHttpInfo($modelId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteModelAsyncWithHttpInfo
     *
     * Delete model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModelAsyncWithHttpInfo($modelId, string $contentType = self::contentTypes['deleteModel'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel';
        $request = $this->deleteModelRequest($modelId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteModel'
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteModelRequest($modelId, string $contentType = self::contentTypes['deleteModel'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling deleteModel'
            );
        }


        $resourcePath = '/api/v2/model/{modelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadModelFile
     *
     * Download Grasshopper file.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadModelFile'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function downloadModelFile($modelId, string $contentType = self::contentTypes['downloadModelFile'][0])
    {
        list($response) = $this->downloadModelFileWithHttpInfo($modelId, $contentType);
        return $response;
    }

    /**
     * Operation downloadModelFileWithHttpInfo
     *
     * Download Grasshopper file.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadModelFile'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadModelFileWithHttpInfo($modelId, string $contentType = self::contentTypes['downloadModelFile'][0])
    {
        $request = $this->downloadModelFileRequest($modelId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadModelFileAsync
     *
     * Download Grasshopper file.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadModelFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadModelFileAsync($modelId, string $contentType = self::contentTypes['downloadModelFile'][0])
    {
        return $this->downloadModelFileAsyncWithHttpInfo($modelId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadModelFileAsyncWithHttpInfo
     *
     * Download Grasshopper file.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadModelFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadModelFileAsyncWithHttpInfo($modelId, string $contentType = self::contentTypes['downloadModelFile'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->downloadModelFileRequest($modelId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadModelFile'
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadModelFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadModelFileRequest($modelId, string $contentType = self::contentTypes['downloadModelFile'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling downloadModelFile'
            );
        }


        $resourcePath = '/api/v2/model/{modelId}/file/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCleanupStatus
     *
     * Get the status of all running model cleanup processes.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCleanupStatus'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResGetCleanupStatus|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function getCleanupStatus($modelId, string $contentType = self::contentTypes['getCleanupStatus'][0])
    {
        list($response) = $this->getCleanupStatusWithHttpInfo($modelId, $contentType);
        return $response;
    }

    /**
     * Operation getCleanupStatusWithHttpInfo
     *
     * Get the status of all running model cleanup processes.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCleanupStatus'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResGetCleanupStatus|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCleanupStatusWithHttpInfo($modelId, string $contentType = self::contentTypes['getCleanupStatus'][0])
    {
        $request = $this->getCleanupStatusRequest($modelId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResGetCleanupStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResGetCleanupStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResGetCleanupStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResGetCleanupStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResGetCleanupStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCleanupStatusAsync
     *
     * Get the status of all running model cleanup processes.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCleanupStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCleanupStatusAsync($modelId, string $contentType = self::contentTypes['getCleanupStatus'][0])
    {
        return $this->getCleanupStatusAsyncWithHttpInfo($modelId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCleanupStatusAsyncWithHttpInfo
     *
     * Get the status of all running model cleanup processes.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCleanupStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCleanupStatusAsyncWithHttpInfo($modelId, string $contentType = self::contentTypes['getCleanupStatus'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResGetCleanupStatus';
        $request = $this->getCleanupStatusRequest($modelId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCleanupStatus'
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCleanupStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCleanupStatusRequest($modelId, string $contentType = self::contentTypes['getCleanupStatus'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling getCleanupStatus'
            );
        }


        $resourcePath = '/api/v2/model/{modelId}/cleanup/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getModel
     *
     * Get model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModel'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResGetModel|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function getModel($modelId, string $contentType = self::contentTypes['getModel'][0])
    {
        list($response) = $this->getModelWithHttpInfo($modelId, $contentType);
        return $response;
    }

    /**
     * Operation getModelWithHttpInfo
     *
     * Get model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModel'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResGetModel|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getModelWithHttpInfo($modelId, string $contentType = self::contentTypes['getModel'][0])
    {
        $request = $this->getModelRequest($modelId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResGetModel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResGetModel' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResGetModel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResGetModel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResGetModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getModelAsync
     *
     * Get model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModelAsync($modelId, string $contentType = self::contentTypes['getModel'][0])
    {
        return $this->getModelAsyncWithHttpInfo($modelId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getModelAsyncWithHttpInfo
     *
     * Get model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModelAsyncWithHttpInfo($modelId, string $contentType = self::contentTypes['getModel'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResGetModel';
        $request = $this->getModelRequest($modelId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getModel'
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getModelRequest($modelId, string $contentType = self::contentTypes['getModel'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling getModel'
            );
        }


        $resourcePath = '/api/v2/model/{modelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getModelComputations
     *
     * Get model computation statistics.
     *
     * @param  string $modelId Model ID. (required)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryOrder|null $order Order in which to query computation stats items.  _Default:_ &#x60;desc&#x60; (optional)
     * @param  string|null $timestampFrom Timestamp to query from.  _Default:_ &#x60;0&#x60; (optional)
     * @param  string|null $timestampTo Timestamp to query to.  _Default:_ &#x60;infinity&#x60; (optional)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryComputationStatisticsStatus|null $status Filter computations by the result status.  _Default:_ &#x60;*&#x60; (optional)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryComputationType|null $type Filter computations by type.  _Default:_ &#x60;*&#x60; (optional)
     * @param  int|null $limit How many items to return at most.  _Default:_ &#x60;100&#x60; (optional)
     * @param  bool|null $strictLimit Whether the limit shall be attained (if there are enough items).  _Default:_ &#x60;false&#x60; (optional)
     * @param  string|null $offset Continuation token for pagination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelComputations'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResGetModelComputations|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function getModelComputations($modelId, $order = null, $timestampFrom = null, $timestampTo = null, $status = null, $type = null, $limit = null, $strictLimit = null, $offset = null, string $contentType = self::contentTypes['getModelComputations'][0])
    {
        list($response) = $this->getModelComputationsWithHttpInfo($modelId, $order, $timestampFrom, $timestampTo, $status, $type, $limit, $strictLimit, $offset, $contentType);
        return $response;
    }

    /**
     * Operation getModelComputationsWithHttpInfo
     *
     * Get model computation statistics.
     *
     * @param  string $modelId Model ID. (required)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryOrder|null $order Order in which to query computation stats items.  _Default:_ &#x60;desc&#x60; (optional)
     * @param  string|null $timestampFrom Timestamp to query from.  _Default:_ &#x60;0&#x60; (optional)
     * @param  string|null $timestampTo Timestamp to query to.  _Default:_ &#x60;infinity&#x60; (optional)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryComputationStatisticsStatus|null $status Filter computations by the result status.  _Default:_ &#x60;*&#x60; (optional)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryComputationType|null $type Filter computations by type.  _Default:_ &#x60;*&#x60; (optional)
     * @param  int|null $limit How many items to return at most.  _Default:_ &#x60;100&#x60; (optional)
     * @param  bool|null $strictLimit Whether the limit shall be attained (if there are enough items).  _Default:_ &#x60;false&#x60; (optional)
     * @param  string|null $offset Continuation token for pagination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelComputations'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResGetModelComputations|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getModelComputationsWithHttpInfo($modelId, $order = null, $timestampFrom = null, $timestampTo = null, $status = null, $type = null, $limit = null, $strictLimit = null, $offset = null, string $contentType = self::contentTypes['getModelComputations'][0])
    {
        $request = $this->getModelComputationsRequest($modelId, $order, $timestampFrom, $timestampTo, $status, $type, $limit, $strictLimit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResGetModelComputations' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResGetModelComputations' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResGetModelComputations', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResGetModelComputations';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResGetModelComputations',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getModelComputationsAsync
     *
     * Get model computation statistics.
     *
     * @param  string $modelId Model ID. (required)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryOrder|null $order Order in which to query computation stats items.  _Default:_ &#x60;desc&#x60; (optional)
     * @param  string|null $timestampFrom Timestamp to query from.  _Default:_ &#x60;0&#x60; (optional)
     * @param  string|null $timestampTo Timestamp to query to.  _Default:_ &#x60;infinity&#x60; (optional)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryComputationStatisticsStatus|null $status Filter computations by the result status.  _Default:_ &#x60;*&#x60; (optional)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryComputationType|null $type Filter computations by type.  _Default:_ &#x60;*&#x60; (optional)
     * @param  int|null $limit How many items to return at most.  _Default:_ &#x60;100&#x60; (optional)
     * @param  bool|null $strictLimit Whether the limit shall be attained (if there are enough items).  _Default:_ &#x60;false&#x60; (optional)
     * @param  string|null $offset Continuation token for pagination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelComputations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModelComputationsAsync($modelId, $order = null, $timestampFrom = null, $timestampTo = null, $status = null, $type = null, $limit = null, $strictLimit = null, $offset = null, string $contentType = self::contentTypes['getModelComputations'][0])
    {
        return $this->getModelComputationsAsyncWithHttpInfo($modelId, $order, $timestampFrom, $timestampTo, $status, $type, $limit, $strictLimit, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getModelComputationsAsyncWithHttpInfo
     *
     * Get model computation statistics.
     *
     * @param  string $modelId Model ID. (required)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryOrder|null $order Order in which to query computation stats items.  _Default:_ &#x60;desc&#x60; (optional)
     * @param  string|null $timestampFrom Timestamp to query from.  _Default:_ &#x60;0&#x60; (optional)
     * @param  string|null $timestampTo Timestamp to query to.  _Default:_ &#x60;infinity&#x60; (optional)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryComputationStatisticsStatus|null $status Filter computations by the result status.  _Default:_ &#x60;*&#x60; (optional)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryComputationType|null $type Filter computations by type.  _Default:_ &#x60;*&#x60; (optional)
     * @param  int|null $limit How many items to return at most.  _Default:_ &#x60;100&#x60; (optional)
     * @param  bool|null $strictLimit Whether the limit shall be attained (if there are enough items).  _Default:_ &#x60;false&#x60; (optional)
     * @param  string|null $offset Continuation token for pagination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelComputations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModelComputationsAsyncWithHttpInfo($modelId, $order = null, $timestampFrom = null, $timestampTo = null, $status = null, $type = null, $limit = null, $strictLimit = null, $offset = null, string $contentType = self::contentTypes['getModelComputations'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResGetModelComputations';
        $request = $this->getModelComputationsRequest($modelId, $order, $timestampFrom, $timestampTo, $status, $type, $limit, $strictLimit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getModelComputations'
     *
     * @param  string $modelId Model ID. (required)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryOrder|null $order Order in which to query computation stats items.  _Default:_ &#x60;desc&#x60; (optional)
     * @param  string|null $timestampFrom Timestamp to query from.  _Default:_ &#x60;0&#x60; (optional)
     * @param  string|null $timestampTo Timestamp to query to.  _Default:_ &#x60;infinity&#x60; (optional)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryComputationStatisticsStatus|null $status Filter computations by the result status.  _Default:_ &#x60;*&#x60; (optional)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryComputationType|null $type Filter computations by type.  _Default:_ &#x60;*&#x60; (optional)
     * @param  int|null $limit How many items to return at most.  _Default:_ &#x60;100&#x60; (optional)
     * @param  bool|null $strictLimit Whether the limit shall be attained (if there are enough items).  _Default:_ &#x60;false&#x60; (optional)
     * @param  string|null $offset Continuation token for pagination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelComputations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getModelComputationsRequest($modelId, $order = null, $timestampFrom = null, $timestampTo = null, $status = null, $type = null, $limit = null, $strictLimit = null, $offset = null, string $contentType = self::contentTypes['getModelComputations'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling getModelComputations'
            );
        }


        if ($timestampFrom !== null && !preg_match("/^\\d{17}$/", $timestampFrom)) {
            throw new \InvalidArgumentException("invalid value for \"timestampFrom\" when calling ModelApi.getModelComputations, must conform to the pattern /^\\d{17}$/.");
        }
        
        if ($timestampTo !== null && !preg_match("/^\\d{17}$/", $timestampTo)) {
            throw new \InvalidArgumentException("invalid value for \"timestampTo\" when calling ModelApi.getModelComputations, must conform to the pattern /^\\d{17}$/.");
        }
        


        if ($limit !== null && $limit > 100) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling ModelApi.getModelComputations, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling ModelApi.getModelComputations, must be bigger than or equal to 1.');
        }
        



        $resourcePath = '/api/v2/model/{modelId}/computations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'QueryOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestampFrom,
            'timestamp_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestampTo,
            'timestamp_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'QueryComputationStatisticsStatus', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'QueryComputationType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $strictLimit,
            'strict_limit', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getModelConfig
     *
     * Get model config.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelConfig'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResGetModelConfig|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function getModelConfig($modelId, string $contentType = self::contentTypes['getModelConfig'][0])
    {
        list($response) = $this->getModelConfigWithHttpInfo($modelId, $contentType);
        return $response;
    }

    /**
     * Operation getModelConfigWithHttpInfo
     *
     * Get model config.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelConfig'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResGetModelConfig|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getModelConfigWithHttpInfo($modelId, string $contentType = self::contentTypes['getModelConfig'][0])
    {
        $request = $this->getModelConfigRequest($modelId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResGetModelConfig' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResGetModelConfig' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResGetModelConfig', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResGetModelConfig';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResGetModelConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getModelConfigAsync
     *
     * Get model config.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModelConfigAsync($modelId, string $contentType = self::contentTypes['getModelConfig'][0])
    {
        return $this->getModelConfigAsyncWithHttpInfo($modelId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getModelConfigAsyncWithHttpInfo
     *
     * Get model config.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModelConfigAsyncWithHttpInfo($modelId, string $contentType = self::contentTypes['getModelConfig'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResGetModelConfig';
        $request = $this->getModelConfigRequest($modelId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getModelConfig'
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getModelConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getModelConfigRequest($modelId, string $contentType = self::contentTypes['getModelConfig'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling getModelConfig'
            );
        }


        $resourcePath = '/api/v2/model/{modelId}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listModels
     *
     * List models.
     *
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryModelStatus|null $modelStatus Filter models by &#x60;stat&#x60;. (optional)
     * @param  string|null $offset Continuation token for pagination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModels'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResListModels|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function listModels($modelStatus = null, $offset = null, string $contentType = self::contentTypes['listModels'][0])
    {
        list($response) = $this->listModelsWithHttpInfo($modelStatus, $offset, $contentType);
        return $response;
    }

    /**
     * Operation listModelsWithHttpInfo
     *
     * List models.
     *
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryModelStatus|null $modelStatus Filter models by &#x60;stat&#x60;. (optional)
     * @param  string|null $offset Continuation token for pagination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModels'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResListModels|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function listModelsWithHttpInfo($modelStatus = null, $offset = null, string $contentType = self::contentTypes['listModels'][0])
    {
        $request = $this->listModelsRequest($modelStatus, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResListModels' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResListModels' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResListModels', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResListModels';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResListModels',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listModelsAsync
     *
     * List models.
     *
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryModelStatus|null $modelStatus Filter models by &#x60;stat&#x60;. (optional)
     * @param  string|null $offset Continuation token for pagination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listModelsAsync($modelStatus = null, $offset = null, string $contentType = self::contentTypes['listModels'][0])
    {
        return $this->listModelsAsyncWithHttpInfo($modelStatus, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listModelsAsyncWithHttpInfo
     *
     * List models.
     *
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryModelStatus|null $modelStatus Filter models by &#x60;stat&#x60;. (optional)
     * @param  string|null $offset Continuation token for pagination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listModelsAsyncWithHttpInfo($modelStatus = null, $offset = null, string $contentType = self::contentTypes['listModels'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResListModels';
        $request = $this->listModelsRequest($modelStatus, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listModels'
     *
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\QueryModelStatus|null $modelStatus Filter models by &#x60;stat&#x60;. (optional)
     * @param  string|null $offset Continuation token for pagination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listModelsRequest($modelStatus = null, $offset = null, string $contentType = self::contentTypes['listModels'][0])
    {




        $resourcePath = '/api/v2/model/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modelStatus,
            'modelStatus', // param base name
            'QueryModelStatus', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restoreModel
     *
     * Restore a soft-deleted model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreModel'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function restoreModel($modelId, string $contentType = self::contentTypes['restoreModel'][0])
    {
        list($response) = $this->restoreModelWithHttpInfo($modelId, $contentType);
        return $response;
    }

    /**
     * Operation restoreModelWithHttpInfo
     *
     * Restore a soft-deleted model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreModel'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function restoreModelWithHttpInfo($modelId, string $contentType = self::contentTypes['restoreModel'][0])
    {
        $request = $this->restoreModelRequest($modelId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restoreModelAsync
     *
     * Restore a soft-deleted model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreModelAsync($modelId, string $contentType = self::contentTypes['restoreModel'][0])
    {
        return $this->restoreModelAsyncWithHttpInfo($modelId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restoreModelAsyncWithHttpInfo
     *
     * Restore a soft-deleted model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreModelAsyncWithHttpInfo($modelId, string $contentType = self::contentTypes['restoreModel'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResDeleteModel';
        $request = $this->restoreModelRequest($modelId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restoreModel'
     *
     * @param  string $modelId Model ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restoreModelRequest($modelId, string $contentType = self::contentTypes['restoreModel'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling restoreModel'
            );
        }


        $resourcePath = '/api/v2/model/{modelId}/restore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateModel
     *
     * Update model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\ReqModel $reqModel reqModel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateModel'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModel|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function updateModel($modelId, $reqModel, string $contentType = self::contentTypes['updateModel'][0])
    {
        list($response) = $this->updateModelWithHttpInfo($modelId, $reqModel, $contentType);
        return $response;
    }

    /**
     * Operation updateModelWithHttpInfo
     *
     * Update model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\ReqModel $reqModel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateModel'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModel|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateModelWithHttpInfo($modelId, $reqModel, string $contentType = self::contentTypes['updateModel'][0])
    {
        $request = $this->updateModelRequest($modelId, $reqModel, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModel' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateModelAsync
     *
     * Update model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\ReqModel $reqModel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateModelAsync($modelId, $reqModel, string $contentType = self::contentTypes['updateModel'][0])
    {
        return $this->updateModelAsyncWithHttpInfo($modelId, $reqModel, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateModelAsyncWithHttpInfo
     *
     * Update model.
     *
     * @param  string $modelId Model ID. (required)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\ReqModel $reqModel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateModelAsyncWithHttpInfo($modelId, $reqModel, string $contentType = self::contentTypes['updateModel'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModel';
        $request = $this->updateModelRequest($modelId, $reqModel, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateModel'
     *
     * @param  string $modelId Model ID. (required)
     * @param  \ShapeDiver\GeometryApiV2\Client\Model\ReqModel $reqModel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateModelRequest($modelId, $reqModel, string $contentType = self::contentTypes['updateModel'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling updateModel'
            );
        }

        // verify the required parameter 'reqModel' is set
        if ($reqModel === null || (is_array($reqModel) && count($reqModel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reqModel when calling updateModel'
            );
        }


        $resourcePath = '/api/v2/model/{modelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($reqModel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($reqModel));
            } else {
                $httpBody = $reqModel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateModelConfig
     *
     * Update model config.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,mixed> $requestBody requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateModelConfig'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModelConfig|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function updateModelConfig($modelId, $requestBody, string $contentType = self::contentTypes['updateModelConfig'][0])
    {
        list($response) = $this->updateModelConfigWithHttpInfo($modelId, $requestBody, $contentType);
        return $response;
    }

    /**
     * Operation updateModelConfigWithHttpInfo
     *
     * Update model config.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,mixed> $requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateModelConfig'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModelConfig|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateModelConfigWithHttpInfo($modelId, $requestBody, string $contentType = self::contentTypes['updateModelConfig'][0])
    {
        $request = $this->updateModelConfigRequest($modelId, $requestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModelConfig' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModelConfig' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModelConfig', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModelConfig';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModelConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateModelConfigAsync
     *
     * Update model config.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,mixed> $requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateModelConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateModelConfigAsync($modelId, $requestBody, string $contentType = self::contentTypes['updateModelConfig'][0])
    {
        return $this->updateModelConfigAsyncWithHttpInfo($modelId, $requestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateModelConfigAsyncWithHttpInfo
     *
     * Update model config.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,mixed> $requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateModelConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateModelConfigAsyncWithHttpInfo($modelId, $requestBody, string $contentType = self::contentTypes['updateModelConfig'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateModelConfig';
        $request = $this->updateModelConfigRequest($modelId, $requestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateModelConfig'
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,mixed> $requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateModelConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateModelConfigRequest($modelId, $requestBody, string $contentType = self::contentTypes['updateModelConfig'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling updateModelConfig'
            );
        }

        // verify the required parameter 'requestBody' is set
        if ($requestBody === null || (is_array($requestBody) && count($requestBody) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $requestBody when calling updateModelConfig'
            );
        }


        $resourcePath = '/api/v2/model/{modelId}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($requestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($requestBody));
            } else {
                $httpBody = $requestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateParameterDefaultValues
     *
     * Update default value of parameters.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,\ShapeDiver\GeometryApiV2\Client\Model\ReqParameterValue> $requestBody requestBody (required)
     * @param  bool|null $ignoreUnknownParams Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateParameterDefaultValues'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefaultValues|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function updateParameterDefaultValues($modelId, $requestBody, $ignoreUnknownParams = null, string $contentType = self::contentTypes['updateParameterDefaultValues'][0])
    {
        list($response) = $this->updateParameterDefaultValuesWithHttpInfo($modelId, $requestBody, $ignoreUnknownParams, $contentType);
        return $response;
    }

    /**
     * Operation updateParameterDefaultValuesWithHttpInfo
     *
     * Update default value of parameters.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,\ShapeDiver\GeometryApiV2\Client\Model\ReqParameterValue> $requestBody (required)
     * @param  bool|null $ignoreUnknownParams Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateParameterDefaultValues'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefaultValues|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateParameterDefaultValuesWithHttpInfo($modelId, $requestBody, $ignoreUnknownParams = null, string $contentType = self::contentTypes['updateParameterDefaultValues'][0])
    {
        $request = $this->updateParameterDefaultValuesRequest($modelId, $requestBody, $ignoreUnknownParams, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefaultValues' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefaultValues' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefaultValues', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefaultValues';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefaultValues',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateParameterDefaultValuesAsync
     *
     * Update default value of parameters.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,\ShapeDiver\GeometryApiV2\Client\Model\ReqParameterValue> $requestBody (required)
     * @param  bool|null $ignoreUnknownParams Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateParameterDefaultValues'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateParameterDefaultValuesAsync($modelId, $requestBody, $ignoreUnknownParams = null, string $contentType = self::contentTypes['updateParameterDefaultValues'][0])
    {
        return $this->updateParameterDefaultValuesAsyncWithHttpInfo($modelId, $requestBody, $ignoreUnknownParams, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateParameterDefaultValuesAsyncWithHttpInfo
     *
     * Update default value of parameters.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,\ShapeDiver\GeometryApiV2\Client\Model\ReqParameterValue> $requestBody (required)
     * @param  bool|null $ignoreUnknownParams Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateParameterDefaultValues'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateParameterDefaultValuesAsyncWithHttpInfo($modelId, $requestBody, $ignoreUnknownParams = null, string $contentType = self::contentTypes['updateParameterDefaultValues'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefaultValues';
        $request = $this->updateParameterDefaultValuesRequest($modelId, $requestBody, $ignoreUnknownParams, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateParameterDefaultValues'
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,\ShapeDiver\GeometryApiV2\Client\Model\ReqParameterValue> $requestBody (required)
     * @param  bool|null $ignoreUnknownParams Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateParameterDefaultValues'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateParameterDefaultValuesRequest($modelId, $requestBody, $ignoreUnknownParams = null, string $contentType = self::contentTypes['updateParameterDefaultValues'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling updateParameterDefaultValues'
            );
        }

        // verify the required parameter 'requestBody' is set
        if ($requestBody === null || (is_array($requestBody) && count($requestBody) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $requestBody when calling updateParameterDefaultValues'
            );
        }



        $resourcePath = '/api/v2/model/{modelId}/parameter/defval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignoreUnknownParams,
            'ignoreUnknownParams', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($requestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($requestBody));
            } else {
                $httpBody = $requestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateParameterDefinitions
     *
     * Update definition of parameters.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,\ShapeDiver\GeometryApiV2\Client\Model\ReqParameterDefinition> $requestBody requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateParameterDefinitions'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefinitions|\ShapeDiver\GeometryApiV2\Client\Model\ResError
     */
    public function updateParameterDefinitions($modelId, $requestBody, string $contentType = self::contentTypes['updateParameterDefinitions'][0])
    {
        list($response) = $this->updateParameterDefinitionsWithHttpInfo($modelId, $requestBody, $contentType);
        return $response;
    }

    /**
     * Operation updateParameterDefinitionsWithHttpInfo
     *
     * Update definition of parameters.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,\ShapeDiver\GeometryApiV2\Client\Model\ReqParameterDefinition> $requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateParameterDefinitions'] to see the possible values for this operation
     *
     * @throws \ShapeDiver\GeometryApiV2\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefinitions|\ShapeDiver\GeometryApiV2\Client\Model\ResError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateParameterDefinitionsWithHttpInfo($modelId, $requestBody, string $contentType = self::contentTypes['updateParameterDefinitions'][0])
    {
        $request = $this->updateParameterDefinitionsRequest($modelId, $requestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefinitions' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefinitions' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefinitions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ShapeDiver\GeometryApiV2\Client\Model\ResError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ShapeDiver\GeometryApiV2\Client\Model\ResError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefinitions';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefinitions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ShapeDiver\GeometryApiV2\Client\Model\ResError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateParameterDefinitionsAsync
     *
     * Update definition of parameters.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,\ShapeDiver\GeometryApiV2\Client\Model\ReqParameterDefinition> $requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateParameterDefinitions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateParameterDefinitionsAsync($modelId, $requestBody, string $contentType = self::contentTypes['updateParameterDefinitions'][0])
    {
        return $this->updateParameterDefinitionsAsyncWithHttpInfo($modelId, $requestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateParameterDefinitionsAsyncWithHttpInfo
     *
     * Update definition of parameters.
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,\ShapeDiver\GeometryApiV2\Client\Model\ReqParameterDefinition> $requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateParameterDefinitions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateParameterDefinitionsAsyncWithHttpInfo($modelId, $requestBody, string $contentType = self::contentTypes['updateParameterDefinitions'][0])
    {
        $returnType = '\ShapeDiver\GeometryApiV2\Client\Model\ResUpdateParameterDefinitions';
        $request = $this->updateParameterDefinitionsRequest($modelId, $requestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateParameterDefinitions'
     *
     * @param  string $modelId Model ID. (required)
     * @param  array<string,\ShapeDiver\GeometryApiV2\Client\Model\ReqParameterDefinition> $requestBody (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateParameterDefinitions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateParameterDefinitionsRequest($modelId, $requestBody, string $contentType = self::contentTypes['updateParameterDefinitions'][0])
    {

        // verify the required parameter 'modelId' is set
        if ($modelId === null || (is_array($modelId) && count($modelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelId when calling updateParameterDefinitions'
            );
        }

        // verify the required parameter 'requestBody' is set
        if ($requestBody === null || (is_array($requestBody) && count($requestBody) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $requestBody when calling updateParameterDefinitions'
            );
        }


        $resourcePath = '/api/v2/model/{modelId}/parameter';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modelId !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($modelId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($requestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($requestBody));
            } else {
                $httpBody = $requestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
